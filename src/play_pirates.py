import torch
import numpy as np
import pygame
from collections import deque
import argparse
import os
import torch.nn.functional as F

# We need to import the model definitions
from models import WorldModel_ViT, ActionToLatentMLP

# --- Configuration ---
WINDOW_WIDTH = 512
WINDOW_HEIGHT = 512
FPS = 15
SEQUENCE_LENGTH = 16
FRAME_SIZE = (128, 128)

def main(args):
    device = torch.device("mps" if torch.backends.mps.is_available() else "cpu")
    print(f"[INFO] Using device: {device}")

    # --- Load Models ---
    print(f"[INFO] Loading World Model from: {args.world_model_path}")
    world_model = WorldModel_ViT(num_frames=SEQUENCE_LENGTH).to(device)
    world_model.load_state_dict(torch.load(args.world_model_path, map_location=device))
    world_model.eval()
    print("...World Model loaded.")

    print(f"[INFO] Loading Controller Model from: {args.controller_path}")
    controller_model = ActionToLatentMLP().to(device)
    controller_model.load_state_dict(torch.load(args.controller_path, map_location=device))
    controller_model.eval()
    print("...Controller Model loaded.")

    # --- Initialize Game ---
    pygame.init()
    window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
    pygame.display.set_caption("Neural Pirates (Generated by AI)")
    clock = pygame.time.Clock()
    font = pygame.font.SysFont('Arial', 18, bold=True)

    # --- Game State ---
    initial_frame = torch.zeros(1, 3, *FRAME_SIZE, device=device)
    frame_buffer = deque([initial_frame.clone() for _ in range(SEQUENCE_LENGTH)], maxlen=SEQUENCE_LENGTH)
    current_display_frame = (initial_frame.squeeze(0).permute(1, 2, 0).cpu().numpy() * 255).clip(0, 255).astype(np.uint8)

    running = True
    last_action_name = "NOOP"
    while running:
        # --- NEW, ROBUST INPUT HANDLING ---
        action_id = 0
        last_action_name = "NOOP"

        # First, handle events like closing the window
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_ESCAPE or event.key == pygame.K_q:
                    running = False
        
        # Now, check which keys are being held down this frame
        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT]:
            action_id = 1
            last_action_name = "LEFT"
        elif keys[pygame.K_RIGHT]:
            action_id = 1
            last_action_name = "RIGHT"
        elif keys[pygame.K_UP] or keys[pygame.K_SPACE]:
            action_id = 1
            last_action_name = "JUMP/ACTION"
        # --- END NEW INPUT HANDLING ---


        # --- AI-Powered Game Loop ---
        with torch.no_grad():
            frame_sequence_tensor = torch.cat(list(frame_buffer), dim=0).unsqueeze(0).to(device)
            action_onehot = torch.zeros(1, 2, device=device)
            action_onehot[0, action_id] = 1.0

            predicted_latents_indices = controller_model.sample(action_onehot)
            quantized_latents = world_model.vq.embeddings(predicted_latents_indices)
            quantized_latents = quantized_latents.view(
                1, world_model.encoder.latent_h, world_model.encoder.latent_w, -1
            ).permute(0, 3, 1, 2)
            
            # Decoder generates the next frame
            next_frame = world_model.decoder(quantized_latents)
            
            # Update frame history and prepare for display
            frame_buffer.append(next_frame)
            current_display_frame = (next_frame.squeeze(0).permute(1, 2, 0).cpu().numpy() * 255).clip(0, 255).astype(np.uint8)

        # --- Rendering to Screen ---
        frame_surface = pygame.surfarray.make_surface(np.transpose(current_display_frame, (1, 0, 2)))
        scaled_surface = pygame.transform.scale(frame_surface, (WINDOW_WIDTH, WINDOW_HEIGHT))
        
        window.blit(scaled_surface, (0, 0))
        info_text = font.render(f"ACTION: {last_action_name}", True, (255, 255, 0))
        window.blit(info_text, (10, 10))

        pygame.display.flip()
        clock.tick(FPS)

    pygame.quit()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Play the AI-generated Pirates game.")
    parser.add_argument('--world_model_path', type=str, default='checkpoints/world_model_epoch_3.pth')
    parser.add_argument('--controller_path', type=str, default='checkpoints/controller_best.pth')
    args = parser.parse_args()

    if not os.path.exists(args.world_model_path) or not os.path.exists(args.controller_path):
        print("Error: Model checkpoints not found. Please run the training scripts first.")
    else:
        main(args)